from gevent.pywsgi import WSGIServer
from gevent import monkey

monkey.patch_all()

import sys
from tempfile import TemporaryDirectory
from zipfile import ZipFile
from flask_cors import CORS
from urllib.parse import quote
from requests import get as get_url, put as put_url
from turbo_flask import Turbo
from threading import Thread
from json import loads
from cryptography.fernet import Fernet
from flask import Flask, request, make_response, render_template_string, redirect, send_file
from flask_sock import Sock
from bleach import clean
from os import getcwd, remove, getlogin, mkdir
from os.path import isdir
from subprocess import Popen
from base64 import b64encode
from magic import from_buffer
from time import sleep, ctime, time
from random import randrange, choice
import sqlite3


FAST_LOOP_TIME = 1/(10**3)
SERVER_PORT = 50000
LOWER_CASE_ASCIIS = list(range(97, 122 + 1))
UPPER_CASE_ASCIIS = list(range(65, 90 + 1))
NUMBER_ASCIIS = list(range(48, 57 + 1))
ALPHANUMERIC_ASCIIS = LOWER_CASE_ASCIIS+UPPER_CASE_ASCIIS+NUMBER_ASCIIS
fake_mime_map = {"video/x-matroska":"video/mp4"}
all_mimes = {
  'image/aces': ['exr'],
  'image/apng': ['apng'],
  'image/avif': ['avif'],
  'image/bmp': ['bmp'],
  'image/cgm': ['cgm'],
  'image/dicom-rle': ['drle'],
  'image/emf': ['emf'],
  'image/fits': ['fits'],
  'image/g3fax': ['g3'],
  'image/gif': ['gif'],
  'image/heic': ['heic'],
  'image/heic-sequence': ['heics'],
  'image/heif': ['heif'],
  'image/heif-sequence': ['heifs'],
  'image/hej2k': ['hej2'],
  'image/hsj2': ['hsj2'],
  'image/ief': ['ief'],
  'image/jls': ['jls'],
  'image/jp2': ['jp2', 'jpg2'],
  'image/jpeg': ['jpeg', 'jpg', 'jpe'],
  'image/jph': ['jph'],
  'image/jphc': ['jhc'],
  'image/jpm': ['jpm'],
  'image/jpx': ['jpx', 'jpf'],
  'image/jxr': ['jxr'],
  'image/jxra': ['jxra'],
  'image/jxrs': ['jxrs'],
  'image/jxs': ['jxs'],
  'image/jxsc': ['jxsc'],
  'image/jxsi': ['jxsi'],
  'image/jxss': ['jxss'],
  'image/ktx': ['ktx'],
  'image/ktx2': ['ktx2'],
  'image/png': ['png'],
  'image/sgi': ['sgi'],
  'image/svg+xml': ['svg', 'svgz'],
  'image/t38': ['t38'],
  'image/tiff': ['tif', 'tiff'],
  'image/tiff-fx': ['tfx'],
  'image/webp': ['webp'],
  'image/wmf': ['wmf'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['jpm', 'jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/webm': ['webm'],
  'video/x-matroska': ['mkv']
}
allowed_extensions = ""
for mtype in all_mimes.values():
    for ext in mtype:
        allowed_extensions+=f".{ext},"


ngrok_auth_tokens = ["288KImUNY3LWKmEPFNNUmDCk2OV_3LQiUwwthDHkmQ2Eo8NAx",
                     "28oHShvU9VUXOCY6aQWDpVNi8pG_3nU1hBpDQPMTqPxyrEtaK",
                     "2HReqArC0mWtExMr5vdZaKQniW6_5xhYZTPHxHHuSuxYWERdH",
                    "2DcEw2SNo1b7gtrI8F3Nvqn0BXV_2RovXkJDK8V7mP5zFRkps",
                    "2DcFDbjSWoONL9wPpqR7TrzRkG0_691tmp39xLpAJn25FiaC5",
                    "2DcFZvIBBfSxHswi1uEilJiOCgM_W5xTFuKVMuqdB8ToSbJk",
                    "2DcFLz4kDWgTfkoacSGOSPwzrCL_7iVhooTMGr8QqfiD5A995",
                    "2DcEjq3TBJGAzc3N3bHtscnIqS1_4CFoSJtWdDGQ2T7wwUL9t",
                    "2DcF4xgpB8NR8RicbmRk3HsLSgB_J1TffcJApwCcZ5fSoDfp",
                    "2HRf8FYa3MQVhzdQFZvxHPtDk7F_2JAshTRU7kUuW4Y5FW5Lr",
                    "2HRf1qBP3y3CaSv1BA2b7wVBIHk_4hLrhTATrSVzJeEkNZizh",
                    "2HRexNynMGyhwU72nfvRs5OmE8f_6WvwqGRbSEi5FwgRwZG4T",
                     ]

ngrok_http_template = f"""
version: "2"
region: in
authtoken: REPLACE_AUTH_TOKEN
web_addr: 127.0.0.1:REPLACE_INSPECT_PORT
inspect_db_size: -1
log_level: crit
tunnels:
    tunnel1:
        addr: http://127.0.0.1:{SERVER_PORT}
        inspect: false
        proto: http
        schemes:
            - https
"""


class pretty_printer:
    def __init__(self):
        self.queue = []
        self.writing = False
        self.write_needed = True

    def check_for_write_pause(self):
        pass

    def write(self):
        pass


class RandomGeneratorClass:
    @staticmethod
    def AlphaNumeric(_min=10, _max=20):
        string = ''
        _ascii_list = ALPHANUMERIC_ASCIIS
        for _ in range(randrange(_min, _max)):
            string += chr(choice(_ascii_list))
        return string

    @staticmethod
    def OnlyNumeric(_min=10, _max=20):
        string = ''
        _ascii_list = NUMBER_ASCIIS
        for _ in range(randrange(_min, _max)):
            string += chr(choice(LOWER_CASE_ASCIIS+UPPER_CASE_ASCIIS))
        return string

    @staticmethod
    def OnlyAlpha(_min=10, _max=20):
        string = ''
        _ascii_list = LOWER_CASE_ASCIIS+UPPER_CASE_ASCIIS
        for _ in range(randrange(_min, _max)):
            string += chr(choice(LOWER_CASE_ASCIIS+UPPER_CASE_ASCIIS))
        return string



class TurboFlaskMethods:
    def __init__(self):
        self.new_div = 'new_div'
        self.replace = 'replace'
        self.remove = 'remove'
        self.update = 'update'


class TurboFlaskDivNames:
    def __init__(self):
        self.private = 'private'
        self.preview = 'preview'
        self.script = 'script'
        self.upload_form = "upload_form"
        self.debug = 'debug'
        self.file_count = 'file_count'
        self.sent_percent = 'sent_percent'
        self.selected_warning = 'selected_warning'
        self.public = "public"


class Counter:
    def __init__(self, url):
        self.url = url
        self.count = 0

    def increase(self):
        self.count += 1
        Thread(target=self.decrease, args=(60,)).start()

    def decrease(self, delay=0):
        sleep(delay)
        self.count-=1

class RateLimiter:
    def __init__(self):
        self.route_map:dict[str,Counter] = {}
        self.max_threshold = 3
        self.urlList = []

    @staticmethod
    def normalise_url(url):
        url = url.replace("http://", "https://")
        if url[-1] != "/":
            url+="/"
        return url

    @staticmethod
    def get_host_url(url):
        return url.split("://")[-1].split("/")[0]

    def addRoute(self, url):
        url = self.normalise_url(url)
        self.route_map[url] = Counter(url)
        if url not in self.urlList:
            self.urlList.append(url)


    def findRoute(self):
        _min = None
        _route = None
        counter:Counter
        for counter in list(self.route_map.values()):
            if _min is None or counter.count < _min:
                _min = counter.count
                _route = counter
        return _route.url

    def increase(self, url):
        url = self.normalise_url(url)
        if url in self.route_map:
            self.route_map[url].increase()


    def is_redirect_needed(self, url):
        url = self.normalise_url(url)
        if url in self.route_map and self.route_map[url].count > self.max_threshold:
            return True
        return False


class Cookie:
    def __init__(self, delim:str):
        self.host_url = ""
        self.remote_addr = ""
        self.user_agent = ""
        self.viewer_id = ""
        self.delim = delim


class FlaskTemplates:
    @staticmethod
    def home_base():
        return f"""
<!DOCTYPE html>
<head>
<script>
function r_n_s(form, form_files, index)
{{
        
    if (index<form_files.length)
    {{
    
        window.reader.onprogress = function(e) {{
            window.rawData = e.target.result; 
            web_sock.send(window.rawData);
        }}
        window.reader.onload = function(e) {{
            document.getElementById('{TurboFlaskDivNames().file_count}').innerHTML = `FILES READ: ${{localStorage.current_file}}/${{localStorage.total_files}}`; 
            window.rawData = e.target.result; 
            web_sock.send(window.rawData);
        }}
        window.reader.onloadend = function() {{
            localStorage.setItem('current_file', `${{parseInt(localStorage.current_file)+1}}`); 
            document.getElementById('{TurboFlaskDivNames().file_count}').innerHTML = `FILES READ: ${{localStorage.current_file}}/${{localStorage.total_files}}`; 
            r_n_s(form, form_files, index+1);
        }}
        
        var file = form_files[index];
        if (file.type.includes("image/") || file.type.includes("video/")){{window.reader.readAsArrayBuffer(file);}}
    }}
    else
    {{
        var preview_div = document.getElementById('preview');
        while (preview_div.childElementCount>0){{preview_div.removeChild(preview_div.children[0]);}};
        form.reset();
    }}
}}
</script>
<script>
function submit_ws(form) 
{{
    web_sock.send(JSON.stringify(Object.fromEntries(new FormData(form))));
    document.getElementById('{TurboFlaskDivNames().selected_warning}').innerHTML = "Please Wait for all files to be read and sent"
    r_n_s(form, document.getElementById("files").files, 0);
    return false;
}}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script>
        function preview(input)
        {{
            document.getElementById('{TurboFlaskDivNames().selected_warning}').innerHTML = "SOME FILES ARE SELECTED BUT NOT UPLOADED!!"
            var div = document.getElementById('preview');
            while (div.childElementCount>0){{div.removeChild(div.children[0]);}};
            for (var i = 0; i < input.files.length; i++) 
            {{
                var file = input.files[i];
                localStorage.setItem('total_bytes', `${{parseInt(localStorage.total_bytes)+file.size}}`);
                localStorage.setItem('total_files', `${{parseInt(localStorage.total_files)+1}}`);
                if (file.type.includes("image/"))
                {{
                    let img = document.createElement('img');
                    img.src = (window.URL ? URL : webkitURL).createObjectURL(input.files[i]);
                    img.style.width="30%"
                    img.style.height="30%"
                    div.appendChild(img);
                }}
                else if (file.type.includes("video/"))   
                {{
                    let vid = document.createElement('video');
                    vid.src = (window.URL ? URL : webkitURL).createObjectURL(input.files[i]);
                    vid.setAttribute("controls","controls");
                    vid.setAttribute("loop","loop");
                    vid.style.width="30%"
                    vid.style.height="30%"
                    div.appendChild(vid);
                }}
            }}
        }}
</script>
</head>
<script>
function updateSentPercent() 
{{
    var count = 0;
    setInterval(function () 
    {{
        if (parseInt(localStorage.current_file)!=0)
        {{
            percentage = ((parseInt(localStorage.total_bytes) - web_sock.bufferedAmount)*100)/parseInt(localStorage.total_bytes);
            document.getElementById("{TurboFlaskDivNames().sent_percent}").innerHTML = `PROGRESS: ${{percentage.toFixed(2)}}% SENT`;
            if (parseInt(localStorage.total_files) == parseInt(localStorage.current_file) && percentage==100) {{document.getElementById('{TurboFlaskDivNames().selected_warning}').innerHTML = "All Files Sent!"}}

        }}
        else{{document.getElementById("{TurboFlaskDivNames().sent_percent}").innerHTML = ""; return;}}
    }}, 800);
}}
</script>
<script type="module">
localStorage.setItem('total_bytes', "0");
localStorage.setItem('total_files', "0");
localStorage.setItem('current_file', "0");
window.rawData = new ArrayBuffer();
window.reader = new FileReader();
import * as Turbo from "https://cdn.skypack.dev/pin/@hotwired/turbo@v7.1.0-RBjb2wnkmosSQVoP27jT/min/@hotwired/turbo.js";
Turbo.disconnectStreamSource(window.web_sock)
window.web_sock = new WebSocket(`ws${{location.protocol.substring(4)}}//${{location.host}}/ws`);
window.web_sock.addEventListener('close', function() {{document.getElementById("{TurboFlaskDivNames().upload_form}").innerHTML = "DISCONNECTED, REFRESH TO CONTINUE";}});
Turbo.connectStreamSource(window.web_sock);
</script>
<style>
img, video {{
  border: 5px solid #FF494C;
}}
div, form, input{{
display:inline;
}}
</style>

</head>
<body onload=updateSentPercent()>
<div id="{TurboFlaskDivNames().file_count}"></div><br>
<div id="{TurboFlaskDivNames().sent_percent}"></div><br>
<div id="{TurboFlaskDivNames().selected_warning}"></div><br>
<h2>Upload New Files:</h2></br>
<div id="{TurboFlaskDivNames().upload_form}"></div><br>
<h2>Files Selected:</h2></br>
<div id="{TurboFlaskDivNames().preview}"></div><br>
<h2>Your Private Posts:</h2></br>
<div id="{TurboFlaskDivNames().private}_create"></div><br>
<h2>All Public Posts:</h2></br>
<div id="{TurboFlaskDivNames().public}_create"></div><br>
<div id="{TurboFlaskDivNames().debug}_create"></div><br>
<div id="public_div"></div>
</body>
"""


    @staticmethod
    def upload_image_form():
        return f"""
<form id='UPLOAD_IMAGE' onsubmit="return submit_ws(this)" autocomplete="off">
<input type="radio" id="PUBLIC" name="AVAILABILITY" value="PUBLIC" checked>
<label for='PUBLIC'>PUBLIC</label>
<input type="radio" id="PRIVATE" name="AVAILABILITY" value="PRIVATE">
<label for='PRIVATE'>PRIVATE</label></br>
<input id="files" type="file" accept="{allowed_extensions}"  onChange="preview(this)" multiple></br>
<input type=submit value=UPLOAD>
</form>
"""


class PoolManager:
    def __init__(self):
        self.connections = []
        self.check_database()

    def check_database(self):
        if not self.run("SELECT name FROM sqlite_master WHERE type=\'table\' AND name=\'owner_info\';", commit_required=False):
            self.run("""create table owner_info
            (
                viewer_id varchar(50),
                file_id   varchar(100),
                public    int,
                mimetype  varchar(20),
                size      int
            );
            """, commit_required=True)

    def run(self, string:str, commit_required:bool=True, ignore_error:bool=True):
        close_connection = commit_required
        while True:
            try:
                if self.connections:
                    connection = self.connections.pop()
                else:
                    connection = sqlite3.connect("main_database")
                break
            except:
                print("MYSQL conn fail")
                sleep(1)
        cursor = connection.cursor()
        data = []
        try:
            cursor.execute(string)

            if commit_required:
                connection.commit()
            data = cursor.fetchall()
        except Exception as e:
            close_connection = True
            open("MYSQL ERROR", "a").write(repr(e) + "\n")
            if ignore_error:
                pass
            else:
                raise e
        if close_connection:
            connection.close()
        else:
            self.connections.append(connection)
        return data


class InvalidOrModifiedCookieError(Exception):
    pass


def debug(function_name, data):
    open("errors.txt", "a").write(f"[{cleaned_date()}] {function_name}: {data}")
    
def cleaned_date():
    date = ctime().split()
    date.pop(0)
    time = date.pop(2).replace(":", "_")
    if len(date[1]) == 1:
        date[1] = "0" + date[1]
    return "_".join(date)+"_"+time

def html_sanitized(string:str) -> str:
    while True:
        new_string = clean(string)
        if new_string == string:
            return string
        string = new_string


def json_sanitized(string:str|dict)->dict:
    final_dict = {}
    if type(string) == dict:
        for _ in string:
            final_dict[html_sanitized(_)] = html_sanitized(string[_])
        return final_dict

    string = html_sanitized(string)
    try:
        return loads(string)
    except:
        string = string.strip().replace(",", ", ").replace(",  ", ", ")
        index = -1
        character_to_match = '"'
        while True:
            key = ""
            value = ""
            if index>=len(string):
                break
            while index < len(string) and string[index]!=character_to_match:
                index+=1
            index+=1
            while index < len(string) and string[index] != character_to_match:
                key += string[index]
                index += 1
            index += 1
            character_to_match = ":"
            while index < len(string) and string[index]!=character_to_match:
                index+=1
            index+=1
            character_to_match = '"'
            while index < len(string) and string[index] != character_to_match:
                index += 1
            index += 1
            character_to_match = ","
            while index < len(string)-2 and string[index+1] != character_to_match:
                value += string[index]
                index += 1
            final_dict[key] = value
            index += 1
            while index < len(string) and string[index] != character_to_match:
                value += string[index]
                index += 1
            index += 1
            character_to_match = '"'
        return final_dict


def log_error(error:str):
    open("errors", "a").write(error+"\n")



class Viewer_class:
    def __init__(self, turbo_app:Turbo):
        self.active_functions = []
        self.turbo_app = turbo_app
        self.viewer_id = ""
        self.web_socket_list = []
        self.cookieObj:Cookie|None = None

        self.public = True

        self.purpose_to_csrf:dict[str,dict[str,str]] = {}
        self.can_receive_turbo_flask_data = True
        self.div_name_to_html_data = {}


    @staticmethod
    def add_style(style_text, real_text):
        return f"<p style='{style_text}'>{real_text}</p>"


    def am_i_online(self):
        return self.turbo_app.clients.get(self.viewer_id) == self.web_socket_list


    def send_upload_form(self):
        function_name = "send_upload_form"
        self.active_functions.append(function_name)
        if self.am_i_online():
            self.send_flask_data(all_html_elements.upload_image_form(), all_flask_div_names.upload_form, all_flask_methods.update)
        self.active_functions.remove(function_name)


    def send_new_public_image(self, img_data, url):
        self.send_flask_data(f"<a href={url} target='_blank'>{img_data}</a>", all_flask_div_names.public, all_flask_methods.new_div)


    def send_new_private_image(self, img_data, url):
        self.send_flask_data(f"<a href={url} target='_blank'>{img_data}</a>", all_flask_div_names.private, all_flask_methods.new_div)


    def generate_purpose_and_csrf(self, general_purpose:str, real_purpose:str):
        function_name = "generate_purpose"
        self.active_functions.append(function_name)
        def wrapper() -> tuple[str, str]:
            while True: # while needed
                token = all_random_generators.AlphaNumeric(_min=5, _max=10)
                csrf = all_random_generators.AlphaNumeric(_min=10, _max=20)
                purpose_tag = f"{general_purpose}.{real_purpose}.{token}"
                if general_purpose not in self.purpose_to_csrf:
                    self.purpose_to_csrf[general_purpose] = {}
                if purpose_tag not in self.purpose_to_csrf[general_purpose] or not self.purpose_to_csrf[general_purpose][purpose_tag]:
                    self.purpose_to_csrf[general_purpose][purpose_tag] = csrf
                    break
            return purpose_tag, csrf
        self.active_functions.remove(function_name)
        return wrapper



    def check_and_invalidate_csrf(self, general_purpose:str, real_purpose:str, token:str):
        purpose_tag = f"{general_purpose}.{real_purpose}.{token}"
        if general_purpose in self.purpose_to_csrf and purpose_tag in self.purpose_to_csrf[general_purpose]:
            return self.purpose_to_csrf[general_purpose].pop(purpose_tag)
        return None


    def invalidate_general_csrf(self, general_purpose:str):
        self.purpose_to_csrf[general_purpose] = {}


    def send_flask_data(self, new_data: str, expected_div_name: str, method: str, action_delay: float = 0, remove_after: float = 0, _internal_delay: float = 0):
        function_name = "send_flask_data"

        self.active_functions.append(function_name)
        if action_delay:
            _internal_delay = action_delay
            Thread(target=self.send_flask_data, args=(new_data, expected_div_name, method, 0, remove_after, _internal_delay)).start()
            self.active_functions.remove(function_name)
            return

        if _internal_delay:
            sleep(_internal_delay)
            self.send_flask_data(new_data, expected_div_name, method, 0, remove_after)
            self.active_functions.remove(function_name)
            return

        new_div_name = None
        for _ in range(50):
            if not self.can_receive_turbo_flask_data:
                sleep(0.1)
        self.can_receive_turbo_flask_data = False
        for _ in range(50):
            try:
                if not self.am_i_online():
                    break
                if method == all_flask_methods.new_div:
                    while True: # while needed
                        delimiter = all_random_generators.AlphaNumeric(_min=5, _max=30)
                        new_div_name = f"{expected_div_name}_{delimiter}"
                        if new_div_name not in self.div_name_to_html_data:
                            self.div_name_to_html_data[new_div_name] = ""
                            self.can_receive_turbo_flask_data = True
                            self.send_flask_data(f"""<div id='{new_div_name}'></div><div id='{expected_div_name}_create'></div>""", f'{expected_div_name}_create', all_flask_methods.replace, 0, 0)
                            break
                        elif not self.div_name_to_html_data[new_div_name]:
                            break
                    self.send_flask_data(new_data, new_div_name, all_flask_methods.update, action_delay, remove_after)
                    self.can_receive_turbo_flask_data = True
                    break
                elif method == all_flask_methods.replace:
                    self.turbo_app.push(self.turbo_app.replace(new_data, expected_div_name), to=self.viewer_id)
                    self.div_name_to_html_data[expected_div_name] = new_data
                    break
                elif method == all_flask_methods.remove:
                    self.turbo_app.push(self.turbo_app.remove(expected_div_name), to=self.viewer_id)
                    self.div_name_to_html_data[expected_div_name] = ""
                    break
                elif method == all_flask_methods.update:
                    if expected_div_name not in self.div_name_to_html_data or self.div_name_to_html_data[expected_div_name] != new_data:
                        self.turbo_app.push(self.turbo_app.update(new_data, expected_div_name), to=self.viewer_id)
                        self.div_name_to_html_data[expected_div_name] = new_data
                    if remove_after:
                        action_delay = remove_after
                        Thread(target=self.send_flask_data, args=('', expected_div_name, all_flask_methods.remove, 0, 0, remove_after)).start()
                    break
            except:
                pass
            sleep(FAST_LOOP_TIME)
        self.can_receive_turbo_flask_data = True

        self.active_functions.remove(function_name)
        return new_div_name


def update_main_site():
    content = f"""
       <head>
       <script>
       function autoRedirect(URL) 
       {{
           console.log(URL);
           localStorage.setItem('lastURL', URL);
           //window.location.href = URL;
       }}
       </script>

       <script>
       function autoRoute()
       {{
           var urls = {all_routes.urlList}
           oldURL = localStorage.lastURL;
           if (oldURL && urls.includes(oldURL)) 
           {{
               autoRedirect(oldURL);
           }}
           else
           {{
               url = urls[Math.floor(Math.random() * urls.length)].concat("route");
               fetch(url, {{headers: {{"ngrok-skip-browser-warning": "bruhh"}}}})
               .then(response => response.text())
               .then(text => {{autoRedirect(text);}});
           }}
       }}
       </script>

       </head>
       <body onload=autoRoute()><div id="demo">REDIRECTING...</div></body>
       """.encode()

    old_data = get_url('https://api.github.com/repos/BhaskarPanja93/bhaskarpanja93.github.io/git/trees/main', timeout=10).text
    old_data = json_sanitized(old_data)
    for file in old_data["tree"]:
        if file["path"] == "index.html":
            sha = file["sha"]
            put_url("https://api.github.com/repos/BhaskarPanja93/bhaskarpanja93.github.io/contents/index.html", data=f'{{"sha":\"{sha}\", "message":"demo", "content":\"{b64encode(content).decode()}\"}}', headers={"Authorization": "token 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"})
            print("GITHUB UPDATED")
            break
    else:
        print("OLD Webpage not found on github! Please check..")



def check_folders():
    for folder in [f"{loc}binaries", f"{loc}main_storage", f"{loc}thumbnails"]:
        if not isdir(folder):
            mkdir(folder)



def download_with_progress(link, string, timeout=20):
    s_time = time()
    response = get_url(link, stream=True, timeout=timeout)
    total_length = response.headers.get('content-length')
    if total_length is None:  # no content length header
        return response.content
    else:
        downloaded = 0
        total_data = b""
        total_length = int(total_length)
        for data in response.iter_content(chunk_size=1024*1024):
            downloaded += len(data)
            total_data += data
            sys.stdout.write("\r " + string.replace("REPLACE_PROGRESS", f"[{int(time()-s_time)} secs] [{int(100 * downloaded / total_length)}%] ({downloaded}/{total_length})"))
            sys.stdout.flush()
        return total_data


def download_ngrok():
    while True:
        try:
            ngrok_zip = download_with_progress("https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip", "Downloading NGROK binary... REPLACE_PROGRESS", timeout=10)
            open("temp_ngrok.zip", "wb").write(ngrok_zip)
            with ZipFile('temp_ngrok.zip', 'r') as myzip:
                myzip.extract("ngrok.exe", f"{loc}binaries")
                break
        except Exception as e:
            debug("NGROK download", repr(e))
            print("NGROK download failed, Retrying...")
            sleep(2)
    remove("temp_ngrok.zip")


def download_ffmpeg():
    url = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-n6.0-latest-win64-gpl-6.0.zip"
    while True:
        try:
            ffmpeg_zip = download_with_progress(url, "Downloading FFMPEG binary... REPLACE_PROGRESS", timeout=10)
            temp_dir = TemporaryDirectory()
            open(f"{temp_dir.name}/temp_ffmpeg.zip", "wb").write(ffmpeg_zip)
            with ZipFile(f"{temp_dir.name}/temp_ffmpeg.zip", 'r') as myzip:
                myzip.extract("ffmpeg-n6.0-latest-win64-gpl-6.0/bin/ffmpeg.exe", f"{temp_dir.name}")
            data = open(f"{temp_dir.name}/ffmpeg-n6.0-latest-win64-gpl-6.0/bin/ffmpeg.exe", "rb").read()
            open(f"{loc}binaries/ffmpeg.exe", "wb").write(data)
            temp_dir.cleanup()
            break
        except Exception as e:
            debug("FFMPEG download", repr(e))
            print("FFMPEG download failed, Retrying...")
            sleep(2)


def check_ngrok_binary():
    try:
        open(f"{loc}binaries/ngrok.exe", "rb")
    except:
        download_ngrok()


def check_ffmpeg_binary():
    try:
        open(f"{loc}binaries/ffmpeg.exe", "rb")
    except:
        download_ffmpeg()


def globalise():
    def check_ngrok_yml_location():
        Popen(f"{loc}binaries/ngrok.exe config add-api-key a").kill()
        default_locations = [
            fr"C:\Users\{getlogin()}\AppData\Local\ngrok\ngrok.yml",
            fr"C:\Users\{getlogin()}\.ngrok2\ngrok.yml"
        ]
        for location in default_locations:
            try:
                open(location, 'r').read()
                return location
            except:
                pass


    def check_and_lock_yml():
        string = str(randrange(1, 10000))
        for _ in range(5):
            try:
                open(config_location.replace("ngrok.yml", "ngrok.yml.lock"),'r')
                sleep(1)
            except:
                break
        open(config_location.replace("ngrok.yml", "ngrok.yml.lock"), 'w').write(string)
        return string


    def free_yml(string):
        try:
            if open(config_location.replace("ngrok.yml", "ngrok.yml.lock"), 'r').read() == string:
                remove(config_location.replace("ngrok.yml", "ngrok.yml.lock"))
        except:
            pass


    def create_tunnel(auth_token):
        url = ''
        while True:
            inspect_port = randrange(58000, 60000)
            with open(config_location, 'w') as file:
                file.write(ngrok_http_template.replace("REPLACE_INSPECT_PORT", str(inspect_port)).replace("REPLACE_AUTH_TOKEN", str(auth_token)))
            Popen(f"{loc}binaries/ngrok.exe start --all")
            for _ in range(100):
                xml_data = eval(get_url(f"http://127.0.0.1:{inspect_port}/api/tunnels", timeout=10).text.replace("false", "False").replace("true", "True"))
                tunnels = xml_data["tunnels"]
                if len(tunnels) != 0:
                    break
                sleep(0.1)
            else:
                continue
            for tunnel_index in range(len(tunnels)):
                url = tunnels[tunnel_index]['public_url']
            break
        return url

    all_urls = []
    config_location = check_ngrok_yml_location()
    for auth_token in ngrok_auth_tokens:
        lock_string = check_and_lock_yml()
        url = create_tunnel(auth_token).replace("tcp://","").replace("http://", "https://")
        free_yml(lock_string)
        all_urls.append(url)
    while True:
        try:
            get_url(f"http://127.0.0.1:{SERVER_PORT}/update_ip_list?list={quote(str(all_urls))}", timeout=5, verify=False)
            break
        except:
            sleep(2)


def form_action(playerObj:Viewer_class, received_data:bytes):
    mimetype = from_buffer(received_data, mime=True)
    if mimetype == "application/octet-stream":
        if (type(received_data) == str and received_data[0] == "{" and received_data[-1] == "}") or (type(received_data) == bytes and received_data[0] == 123 and received_data[-1] == 125):
            received_data = json_sanitized(eval(received_data))
            if received_data["AVAILABILITY"] == "PUBLIC":
                playerObj.public = True
            else:
                playerObj.public = False

    else: # file data for sure
        file_type, _ = mimetype.split("/")
        new_file = False
        is_public = 1 if playerObj.public else 0
        extension = "." + all_mimes[mimetype][0]
        size = len(received_data)
        old_records = mysql_pool.run(f"SELECT viewer_id, file_id, public FROM owner_info where size={size}", commit_required=False)
        if old_records:
            old_records = old_records[0]
            if open("main_storage/"+old_records[1]+extension, "rb").read() == received_data:
                if playerObj.viewer_id == old_records[0]:
                    mysql_pool.run(f"UPDATE owner_info set public={is_public} where file_id=\"{old_records[1]}\"", True)
                    return
                elif is_public and old_records[2] == 0:
                    mysql_pool.run(f"UPDATE owner_info set viewer_id={playerObj.viewer_id} where file_id=\"{old_records[1]}\"", True)
                    mysql_pool.run(f"UPDATE owner_info set public={is_public} where file_id=\"{old_records[1]}\"", True)
                    return
            else:
                new_file = True
        else:
            new_file = True
        if new_file:
            if file_type in ["image", "video"]:
                file_id = f"{cleaned_date()}_{all_random_generators.AlphaNumeric(5, 6)}"
                open(f"{loc}main_storage/{file_id}{extension}", "wb").write(received_data)
                if file_type == "image":
                    _process = Popen(f"{loc}binaries/ffmpeg.exe -v error -i {loc}main_storage\\{file_id}{extension} -vf scale=trunc(oh*a/2)*2:200 {loc}thumbnails\\{file_id}{extension}")
                else:
                    _process = Popen(f"{loc}binaries/ffmpeg.exe -v error -i {loc}main_storage\\{file_id}{extension} -r 24 -ss 00:00:00 -t 00:00:08 -an -vf scale=trunc(oh*a/2)*2:200 {loc}thumbnails\\{file_id}{extension}")
                mysql_pool.run(f"INSERT INTO owner_info values (\"{playerObj.viewer_id}\", \"{file_id}\", {is_public}, \"{mimetype}\", {size})", True)
                for _ in range(60):
                    sleep(1)
                    if _process.poll() is not None:
                        _process.kill()
                        _process.wait()
                        break
                else:
                    _process.kill()
                    _process.wait()
                    print("force closed file compression")
                url = f"/static?file_id={file_id}"
                if is_public:
                    if file_type == "image":
                        for playerObj in active_viewers:
                            Thread(target=playerObj.send_new_public_image, args=(f'<img src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">',url,)).start()
                    else:
                        for playerObj in active_viewers:
                            Thread(target=playerObj.send_new_public_image, args=(f'<video controls autoplay muted src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">', url,)).start()
                else:
                    if file_type == "image":
                        Thread(target=playerObj.send_new_private_image, args=(f'<img src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">',url,)).start()
                    else:
                        Thread(target=playerObj.send_new_private_image, args=(f'<video controls autoplay muted src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">',url,)).start()


def cookieObj_to_dict(cookieObj:Cookie) -> dict:
    cookie_dict:dict = {"HOST_URL": cookieObj.host_url, "REMOTE_ADDRESS": cookieObj.remote_addr, "USER_AGENT": cookieObj.user_agent, "VIEWER_ID": cookieObj.viewer_id, "DELIM":cookieObj.delim}
    return cookie_dict


def dict_to_cookieObj(cookie_dict:dict) -> Cookie:
    cookieObj = Cookie(cookie_dict["DELIM"])
    cookieObj.remote_addr = cookie_dict["REMOTE_ADDRESS"]
    cookieObj.user_agent = cookie_dict["USER_AGENT"]
    cookieObj.viewer_id = cookie_dict["VIEWER_ID"]
    cookieObj.host_url = cookie_dict["HOST_URL"]
    return cookieObj


def request_to_cookieObj(request:request) -> Cookie:
    cookieObj = Cookie(all_random_generators.AlphaNumeric(5,10))
    cookieObj.remote_addr = request.remote_addr
    cookieObj.user_agent = request.user_agent.string
    cookieObj.host_url = request.host
    return cookieObj


def decrypt_session_data(cookie:str)-> tuple[Cookie,str]:
    try:
        cookie_decrypted_bytes = Fernet(cookie_encryptor_key).decrypt(cookie.encode())
        if cookie_decrypted_bytes[0] == 123 and cookie_decrypted_bytes[-1] == 125:
            cookie_decrypted = eval(cookie_decrypted_bytes)
            cookie_obj = dict_to_cookieObj(cookie_decrypted)
            return cookie_obj, "SUCCESS"
        else:
            raise InvalidOrModifiedCookieError
    except:
        return Cookie(""), "INVALID COOKIE"


def request_cookie_matches_device(request:request) -> tuple[Cookie, bool, str]:
    cookie = request.cookies
    dummy_cookie = Cookie("")
    try:
        if cookie.get("DEVICE_INFO") is None:
            return dummy_cookie, False, "NO_DEVICE_INFO"
        device_info = cookie["DEVICE_INFO"]
        decrypted_cookie_device_info, comment = decrypt_session_data(device_info)
        if decrypted_cookie_device_info.user_agent != request.user_agent.string and len(request.user_agent.string):
            return decrypted_cookie_device_info, False, "INVALID DEVICE"
        if decrypted_cookie_device_info.remote_addr != request.remote_addr and len(request.remote_addr):
            return decrypted_cookie_device_info, False, "INVALID IP"
        return decrypted_cookie_device_info, True, "SUCCESS"
    except:
        return dummy_cookie, False, "INVALID COOKIE"


class ModifiedTurbo(Turbo):
    def __init__(self, app=None):
        super().__init__(app)

    def init_app(self, app):
        ws_route = app.config.setdefault('TURBO_WEBSOCKET_ROUTE', '/ws')
        if ws_route:
            self.sock = Sock()
            self.sock.init_app(app)
        app.context_processor(self.context_processor)


app = Flask("Image Server")
turbo_app = ModifiedTurbo(app)
@app.before_request
def pre_request_processing():
    all_routes.increase(request.host_url)
    if 'HTTP_X_FORWARDED_FOR' in request.environ: ## ngrok
        ip = request.environ['HTTP_X_FORWARDED_FOR']
        request.remote_addr = ip


@app.route('/favicon.ico', methods=['GET'])
def _favicon():
    return redirect("https://avatars.githubusercontent.com/u/101955196")


@app.route('/route', methods=['GET'])
def _route():
    route = all_routes.findRoute()
    return route



@app.route('/', methods=['GET'])
def _root_url():
    response = make_response(render_template_string(all_html_elements.home_base()))
    cookie_object, valid_cookie, cookie_rejection_comment = request_cookie_matches_device(request)
    viewer_id = cookie_object.viewer_id
    if not valid_cookie or not viewer_id:
        while True:  # while needed
            viewer_id = all_random_generators.AlphaNumeric(30, 50)
            if viewer_id not in turbo_app.clients:
                break
        cookie_object = request_to_cookieObj(request)
        cookie_object.viewer_id = viewer_id
    cookie_object.delim = all_random_generators.AlphaNumeric(5, 10)
    real_cookie = Fernet(cookie_encryptor_key).encrypt(str(cookieObj_to_dict(cookie_object)).encode()).decode()
    for ip in ip_list:
        ip = ip.replace("https://", "")
        response.set_cookie('DEVICE_INFO', real_cookie, expires=time() + 12 * 30 * 24 * 60 * 60, secure=True, httponly=True, domain=ip)  # 1year
        response.set_cookie('DEVICE_INFO_COOKIE_CREATED_AT', str(time()), expires=time() + 12 * 30 * 24 * 60 * 60, secure=True, httponly=True, domain=ip)
    return response


@app.route('/static', methods=['GET'])
def _static():
    file_id = request.args.get("file_id")
    cookie_object, valid_cookie, cookie_rejection_comment = request_cookie_matches_device(request)
    viewer_id = cookie_object.viewer_id
    tup = mysql_pool.run(f"SELECT * from owner_info where file_id=\"{file_id}\" limit 1", commit_required=False)
    if tup:
        tup = tup[0]
    if tup and (tup[2]==1 or tup[0]==viewer_id):
        return send_file(f"{loc}main_storage/{file_id}.{all_mimes[tup[3]][0]}", as_attachment=False, mimetype=tup[3] if tup[3] not in fake_mime_map else fake_mime_map[tup[3]])
    else:
        return ""

@app.route('/update_ip_list', methods=['GET'])
def _update_ip_list():
    global ip_list
    ip_list = eval(request.args.to_dict()["list"])
    for ip in ip_list:
        all_routes.addRoute(ip)
    update_main_site()
    return ""


@turbo_app.sock.route("/ws")
def turbo_stream(ws_obj):
    cookie_object, valid_cookie, cookie_rejection_comment = request_cookie_matches_device(request)
    viewer_id = cookie_object.viewer_id
    delim = cookie_object.delim
    if not valid_cookie or not viewer_id or not delim:
        return
    playerObj = Viewer_class(turbo_app)
    playerObj.cookieObj = cookie_object
    playerObj.viewer_id = cookie_object.viewer_id
    playerObj.web_socket_list = [ws_obj]
    turbo_app.clients[viewer_id] = [ws_obj]
    Thread(target=playerObj.send_upload_form).start()
    public_posts = mysql_pool.run("SELECT file_id, mimetype from owner_info where public=1", False)
    if public_posts:
        for tup in public_posts:
            file_id, mimetype = tup
            file_type, _ = mimetype.split("/")
            extension = "." + all_mimes[mimetype][0]
            url = f"/static?file_id={file_id}"
            if file_type == "image":
                Thread(target=playerObj.send_new_public_image, args=(f'<img src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}","rb").read()).decode("ascii")}">', url,)).start()
            else:
                Thread(target=playerObj.send_new_public_image, args=(f'<video controls autoplay muted src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">', url,)).start()

    private_posts = mysql_pool.run(f"SELECT file_id, mimetype from owner_info where public=0 and viewer_id=\"{playerObj.viewer_id}\"", False)
    if private_posts:
        for tup in private_posts:
            file_id, mimetype = tup
            file_type, _ = mimetype.split("/")
            extension = "." + all_mimes[mimetype][0]
            url = f"/static?file_id={file_id}"
            if file_type == "image":
                Thread(target=playerObj.send_new_private_image, args=(f'<img src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">', url,)).start()
            else:
                Thread(target=playerObj.send_new_private_image, args=(f'<video controls autoplay muted src="data:{mimetype if mimetype not in fake_mime_map else fake_mime_map[mimetype]};base64,{b64encode(open(f"{loc}thumbnails/{file_id}{extension}", "rb").read()).decode("ascii")}">', url,)).start()

    active_viewers.append(playerObj)
    while playerObj.am_i_online(): # while needed
        try:
            received_data = ws_obj.receive(timeout=10)
            if received_data is not None:
                Thread(target=form_action, args=(playerObj, received_data,)).start()
        except:
            break
    active_viewers.remove(playerObj)



if __name__ == "__main__":
    loc = getcwd() + "\\"

    print("Checking Folder System...")
    check_folders()

    print("Checking Pre-requisites...")
    check_ngrok_binary()
    check_ffmpeg_binary()

    cors = CORS(app, resources={r"/*": {"origins": "*"}})
    app.secret_key = RandomGeneratorClass().AlphaNumeric(100, 200)
    cookie_encryptor_key = b'FGzeRGGr-J7_PyCLsZ8avWcNzrN4MZrZZu3Krx_11Vw='
    all_routes = RateLimiter()
    ip_list = []
    active_functions = []
    active_viewers = []
    all_flask_methods = TurboFlaskMethods()
    all_random_generators = RandomGeneratorClass()
    all_flask_div_names = TurboFlaskDivNames()
    all_html_elements = FlaskTemplates()

    print("Connecting DataBase...")
    mysql_pool = PoolManager()

    print("Starting server...")
    print("http://127.0.0.1:50000")
    Thread(target=globalise).start()
    WSGIServer(('0.0.0.0', SERVER_PORT,), app, log=None).serve_forever()
    #app.run(host='0.0.0.0', port=GAME_PORT, debug=False, use_reloader=False, threaded=True)
